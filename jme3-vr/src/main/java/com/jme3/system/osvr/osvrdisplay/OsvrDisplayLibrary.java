package com.jme3.system.osvr.osvrdisplay;
import com.jme3.system.osvr.osvrclientkit.OsvrClientKitLibrary;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.FloatByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;

/**
 * JNA Wrapper for library <b>osvrDisplay</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class OsvrDisplayLibrary implements Library {
	public static final String JNA_LIBRARY_NAME = "osvrClientKit";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(OsvrDisplayLibrary.JNA_LIBRARY_NAME);
	static {
		Native.register(OsvrDisplayLibrary.class, OsvrDisplayLibrary.JNA_NATIVE_LIB);
	}
	/**
	 * Allocates a display configuration object populated with data from the<br>
	 * OSVR system.<br>
	 * Before this call will succeed, your application will need to be correctly<br>
	 * and fully connected to an OSVR server. You may consider putting this call in<br>
	 * a loop alternating with osvrClientUpdate() until this call succeeds.<br>
	 * Data provided by a display configuration object:<br>
	 * - The logical display topology (number and relationship of viewers, eyes,<br>
	 * and surfaces), which remains constant throughout the life of the<br>
	 * configuration object. (A method of notification of change here is TBD).<br>
	 * - Pose data for viewers (not required for rendering) and pose/view data for<br>
	 * eyes (used for rendering) which is based on tracker data: if used, these<br>
	 * should be queried every frame.<br>
	 * - Projection matrix data for surfaces, which while in current practice may<br>
	 * be relatively unchanging, we are not guaranteeing them to be constant:<br>
	 * these should be queried every frame.<br>
	 * - Video-input-relative viewport size/location for a surface: would like this<br>
	 * to be variable, but probably not feasible. If you have input, please<br>
	 * comment on the dev mailing list.<br>
	 * - Per-surface distortion strategy priorities/availabilities: constant. Note<br>
	 * the following, though...<br>
	 * - Per-surface distortion strategy parameters: variable, request each frame.<br>
	 * (Could make constant with a notification if needed?)<br>
	 * Important note: While most of this data is immediately available if you are<br>
	 * successful in getting a display config object, the pose-based data (viewer<br>
	 * pose, eye pose, eye view matrix) needs tracker state, so at least one (and in<br>
	 * practice, typically more) osvrClientUpdate() must be performed before a new<br>
	 * tracker report is available to populate that state. See<br>
	 * osvrClientCheckDisplayStartup() to query if all startup data is available.<br>
	 * todo Decide if relative viewport should be constant in a display config,<br>
	 * and update docs accordingly.<br>
	 * todo Decide if distortion params should be constant in a display config,<br>
	 * and update docs accordingly.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or some other<br>
	 * error occurred, in which case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetDisplay(OSVR_ClientContext, OSVR_DisplayConfig*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetDisplay(com.jme3.system.osvr.osvrclientkit.OsvrClientKitLibrary.OSVR_ClientContext, com.sun.jna.ptr.PointerByReference)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetDisplay(Pointer ctx, Pointer disp);
	/**
	 * Allocates a display configuration object populated with data from the<br>
	 * OSVR system.<br>
	 * Before this call will succeed, your application will need to be correctly<br>
	 * and fully connected to an OSVR server. You may consider putting this call in<br>
	 * a loop alternating with osvrClientUpdate() until this call succeeds.<br>
	 * Data provided by a display configuration object:<br>
	 * - The logical display topology (number and relationship of viewers, eyes,<br>
	 * and surfaces), which remains constant throughout the life of the<br>
	 * configuration object. (A method of notification of change here is TBD).<br>
	 * - Pose data for viewers (not required for rendering) and pose/view data for<br>
	 * eyes (used for rendering) which is based on tracker data: if used, these<br>
	 * should be queried every frame.<br>
	 * - Projection matrix data for surfaces, which while in current practice may<br>
	 * be relatively unchanging, we are not guaranteeing them to be constant:<br>
	 * these should be queried every frame.<br>
	 * - Video-input-relative viewport size/location for a surface: would like this<br>
	 * to be variable, but probably not feasible. If you have input, please<br>
	 * comment on the dev mailing list.<br>
	 * - Per-surface distortion strategy priorities/availabilities: constant. Note<br>
	 * the following, though...<br>
	 * - Per-surface distortion strategy parameters: variable, request each frame.<br>
	 * (Could make constant with a notification if needed?)<br>
	 * Important note: While most of this data is immediately available if you are<br>
	 * successful in getting a display config object, the pose-based data (viewer<br>
	 * pose, eye pose, eye view matrix) needs tracker state, so at least one (and in<br>
	 * practice, typically more) osvrClientUpdate() must be performed before a new<br>
	 * tracker report is available to populate that state. See<br>
	 * osvrClientCheckDisplayStartup() to query if all startup data is available.<br>
	 * todo Decide if relative viewport should be constant in a display config,<br>
	 * and update docs accordingly.<br>
	 * todo Decide if distortion params should be constant in a display config,<br>
	 * and update docs accordingly.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or some other<br>
	 * error occurred, in which case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetDisplay(OSVR_ClientContext, OSVR_DisplayConfig*)</code>
	 */
	public static native byte osvrClientGetDisplay(OsvrClientKitLibrary.OSVR_ClientContext ctx, PointerByReference disp);
	/**
	 * Allocates a display configuration object populated with data from the<br>
	 * OSVR system.<br>
	 * Before this call will succeed, your application will need to be correctly<br>
	 * and fully connected to an OSVR server. You may consider putting this call in<br>
	 * a loop alternating with osvrClientUpdate() until this call succeeds.<br>
	 * Data provided by a display configuration object:<br>
	 * - The logical display topology (number and relationship of viewers, eyes,<br>
	 * and surfaces), which remains constant throughout the life of the<br>
	 * configuration object. (A method of notification of change here is TBD).<br>
	 * - Pose data for viewers (not required for rendering) and pose/view data for<br>
	 * eyes (used for rendering) which is based on tracker data: if used, these<br>
	 * should be queried every frame.<br>
	 * - Projection matrix data for surfaces, which while in current practice may<br>
	 * be relatively unchanging, we are not guaranteeing them to be constant:<br>
	 * these should be queried every frame.<br>
	 * - Video-input-relative viewport size/location for a surface: would like this<br>
	 * to be variable, but probably not feasible. If you have input, please<br>
	 * comment on the dev mailing list.<br>
	 * - Per-surface distortion strategy priorities/availabilities: constant. Note<br>
	 * the following, though...<br>
	 * - Per-surface distortion strategy parameters: variable, request each frame.<br>
	 * (Could make constant with a notification if needed?)<br>
	 * Important note: While most of this data is immediately available if you are<br>
	 * successful in getting a display config object, the pose-based data (viewer<br>
	 * pose, eye pose, eye view matrix) needs tracker state, so at least one (and in<br>
	 * practice, typically more) osvrClientUpdate() must be performed before a new<br>
	 * tracker report is available to populate that state. See<br>
	 * osvrClientCheckDisplayStartup() to query if all startup data is available.<br>
	 * todo Decide if relative viewport should be constant in a display config,<br>
	 * and update docs accordingly.<br>
	 * todo Decide if distortion params should be constant in a display config,<br>
	 * and update docs accordingly.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or some other<br>
	 * error occurred, in which case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetDisplay(OSVR_ClientContext, OSVR_DisplayConfig*)</code>
	 */
	public static native byte osvrClientGetDisplay(Pointer ctx, PointerByReference disp);
	/**
	 * Frees a display configuration object. The corresponding context must<br>
	 * still be open.<br>
	 * If you fail to call this, it will be automatically called as part of<br>
	 * clean-up when the corresponding context is closed.<br>
	 * @return OSVR_RETURN_FAILURE if a null config was passed, or if the given<br>
	 * display object was already freed.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientFreeDisplay(OSVR_DisplayConfig)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientFreeDisplay(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientFreeDisplay(Pointer disp);
	/**
	 * Frees a display configuration object. The corresponding context must<br>
	 * still be open.<br>
	 * If you fail to call this, it will be automatically called as part of<br>
	 * clean-up when the corresponding context is closed.<br>
	 * @return OSVR_RETURN_FAILURE if a null config was passed, or if the given<br>
	 * display object was already freed.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientFreeDisplay(OSVR_DisplayConfig)</code>
	 */
	public static native byte osvrClientFreeDisplay(OsvrDisplayLibrary.OSVR_DisplayConfig disp);
	/**
	 * Checks to see if a display is fully configured and ready, including<br>
	 * having received its first pose update.<br>
	 * Once this first succeeds, it will continue to succeed for the lifetime of<br>
	 * the display config object, so it is not necessary to keep calling once you<br>
	 * get a successful result.<br>
	 * @return OSVR_RETURN_FAILURE if a null config was passed, or if the given<br>
	 * display config object was otherwise not ready for full use.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientCheckDisplayStartup(OSVR_DisplayConfig)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientCheckDisplayStartup(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientCheckDisplayStartup(Pointer disp);
	/**
	 * Checks to see if a display is fully configured and ready, including<br>
	 * having received its first pose update.<br>
	 * Once this first succeeds, it will continue to succeed for the lifetime of<br>
	 * the display config object, so it is not necessary to keep calling once you<br>
	 * get a successful result.<br>
	 * @return OSVR_RETURN_FAILURE if a null config was passed, or if the given<br>
	 * display config object was otherwise not ready for full use.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientCheckDisplayStartup(OSVR_DisplayConfig)</code>
	 */
	public static native byte osvrClientCheckDisplayStartup(OsvrDisplayLibrary.OSVR_DisplayConfig disp);
	/**
	 * A display config can have one or more display inputs to pass pixels<br>
	 * over (HDMI/DVI connections, etc): retrieve the number of display inputs in<br>
	 * the current configuration.<br>
	 * @param disp Display config object.<br>
	 * @param numDisplayInputs Number of display inputs in the logical display<br>
	 * topology, **constant** throughout the active, valid lifetime of a display<br>
	 * config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in<br>
	 * which case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetNumDisplayInputs(OSVR_DisplayConfig, OSVR_DisplayInputCount*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetNumDisplayInputs(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, java.nio.ByteBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetNumDisplayInputs(Pointer disp, Pointer numDisplayInputs);
	/**
	 * A display config can have one or more display inputs to pass pixels<br>
	 * over (HDMI/DVI connections, etc): retrieve the number of display inputs in<br>
	 * the current configuration.<br>
	 * @param disp Display config object.<br>
	 * @param numDisplayInputs Number of display inputs in the logical display<br>
	 * topology, **constant** throughout the active, valid lifetime of a display<br>
	 * config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in<br>
	 * which case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetNumDisplayInputs(OSVR_DisplayConfig, OSVR_DisplayInputCount*)</code>
	 */
	public static native byte osvrClientGetNumDisplayInputs(OsvrDisplayLibrary.OSVR_DisplayConfig disp, ByteBuffer numDisplayInputs);
	/**
	 * Retrieve the pixel dimensions of a given display input for a display<br>
	 * config<br>
	 * @param disp Display config object.<br>
	 * @param displayInputIndex The zero-based index of the display input.<br>
	 * @param width Width (in pixels) of the display input.<br>
	 * @param height Height (in pixels) of the display input.<br>
	 * The out parameters are **constant** throughout the active, valid lifetime of<br>
	 * a display config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in<br>
	 * which case the output arguments are unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetDisplayDimensions(OSVR_DisplayConfig, OSVR_DisplayInputCount, OSVR_DisplayDimension*, OSVR_DisplayDimension*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetDisplayDimensions(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, byte, java.nio.IntBuffer, java.nio.IntBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetDisplayDimensions(Pointer disp, byte displayInputIndex, IntByReference width, IntByReference height);
	/**
	 * Retrieve the pixel dimensions of a given display input for a display<br>
	 * config<br>
	 * @param disp Display config object.<br>
	 * @param displayInputIndex The zero-based index of the display input.<br>
	 * @param width Width (in pixels) of the display input.<br>
	 * @param height Height (in pixels) of the display input.<br>
	 * The out parameters are **constant** throughout the active, valid lifetime of<br>
	 * a display config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in<br>
	 * which case the output arguments are unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetDisplayDimensions(OSVR_DisplayConfig, OSVR_DisplayInputCount, OSVR_DisplayDimension*, OSVR_DisplayDimension*)</code>
	 */
	public static native byte osvrClientGetDisplayDimensions(OsvrDisplayLibrary.OSVR_DisplayConfig disp, byte displayInputIndex, IntBuffer width, IntBuffer height);
	/**
	 * A display config can have one (or theoretically more) viewers:<br>
	 * retrieve the viewer count.<br>
	 * @param disp Display config object.<br>
	 * @param viewers Number of viewers in the logical display topology,<br>
	 * *constant** throughout the active, valid lifetime of a display config<br>
	 * object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetNumViewers(OSVR_DisplayConfig, OSVR_ViewerCount*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetNumViewers(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, java.nio.IntBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetNumViewers(Pointer disp, IntByReference viewers);
	/**
	 * A display config can have one (or theoretically more) viewers:<br>
	 * retrieve the viewer count.<br>
	 * @param disp Display config object.<br>
	 * @param viewers Number of viewers in the logical display topology,<br>
	 * *constant** throughout the active, valid lifetime of a display config<br>
	 * object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetNumViewers(OSVR_DisplayConfig, OSVR_ViewerCount*)</code>
	 */
	public static native byte osvrClientGetNumViewers(OsvrDisplayLibrary.OSVR_DisplayConfig disp, IntBuffer viewers);
	/**
	 * Get the pose of a viewer in a display config.<br>
	 * Note that there may not necessarily be any surfaces rendered from this pose<br>
	 * (it's the unused "center" eye in a stereo configuration, for instance) so<br>
	 * only use this if it makes integration into your engine or existing<br>
	 * applications (not originally designed for stereo) easier.<br>
	 * Will only succeed if osvrClientCheckDisplayStartup() succeeds.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or no pose was<br>
	 * yet available, in which case the pose argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerPose(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_Pose3*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetViewerPose(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, com.sun.jna.Pointer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerPose(Pointer disp, int viewer, Pointer pose);
	/**
	 * Get the pose of a viewer in a display config.<br>
	 * Note that there may not necessarily be any surfaces rendered from this pose<br>
	 * (it's the unused "center" eye in a stereo configuration, for instance) so<br>
	 * only use this if it makes integration into your engine or existing<br>
	 * applications (not originally designed for stereo) easier.<br>
	 * Will only succeed if osvrClientCheckDisplayStartup() succeeds.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or no pose was<br>
	 * yet available, in which case the pose argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerPose(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_Pose3*)</code>
	 */
	public static native byte osvrClientGetViewerPose(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, Pointer pose);
	/**
	 * Each viewer in a display config can have one or more "eyes" which<br>
	 * have a substantially similar pose: get the count.<br>
	 * @param disp Display config object.<br>
	 * @param viewer Viewer ID<br>
	 * @param eyes Number of eyes for this viewer in the logical display<br>
	 * topology, **constant** throughout the active, valid lifetime of a display<br>
	 * config object<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetNumEyesForViewer(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetNumEyesForViewer(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, java.nio.ByteBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetNumEyesForViewer(Pointer disp, int viewer, Pointer eyes);
	/**
	 * Each viewer in a display config can have one or more "eyes" which<br>
	 * have a substantially similar pose: get the count.<br>
	 * @param disp Display config object.<br>
	 * @param viewer Viewer ID<br>
	 * @param eyes Number of eyes for this viewer in the logical display<br>
	 * topology, **constant** throughout the active, valid lifetime of a display<br>
	 * config object<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetNumEyesForViewer(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount*)</code>
	 */
	public static native byte osvrClientGetNumEyesForViewer(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, ByteBuffer eyes);
	/**
	 * Get the "viewpoint" for the given eye of a viewer in a display<br>
	 * config.<br>
	 * Will only succeed if osvrClientCheckDisplayStartup() succeeds.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param pose Room-space pose (not relative to pose of the viewer)<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or no pose was<br>
	 * yet available, in which case the pose argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyePose(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_Pose3*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetViewerEyePose(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, com.sun.jna.Pointer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerEyePose(Pointer disp, int viewer, byte eye, Pointer pose);
	/**
	 * Get the "viewpoint" for the given eye of a viewer in a display<br>
	 * config.<br>
	 * Will only succeed if osvrClientCheckDisplayStartup() succeeds.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param pose Room-space pose (not relative to pose of the viewer)<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or no pose was<br>
	 * yet available, in which case the pose argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyePose(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_Pose3*)</code>
	 */
	public static native byte osvrClientGetViewerEyePose(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, Pointer pose);
	/**
	 * Get the view matrix (inverse of pose) for the given eye of a<br>
	 * viewer in a display config - matrix of **doubles**.<br>
	 * Will only succeed if osvrClientCheckDisplayStartup() succeeds.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param flags Bitwise OR of matrix convention flags (see @ref MatrixFlags)<br>
	 * @param mat Pass a double[::OSVR_MATRIX_SIZE] to get the transformation<br>
	 * matrix from room space to eye space (not relative to pose of the viewer)<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or no pose was<br>
	 * yet available, in which case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeViewMatrixd(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_MatrixConventions, double*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetViewerEyeViewMatrixd(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, short, java.nio.DoubleBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerEyeViewMatrixd(Pointer disp, int viewer, byte eye, short flags, DoubleByReference mat);
	/**
	 * Get the view matrix (inverse of pose) for the given eye of a<br>
	 * viewer in a display config - matrix of **doubles**.<br>
	 * Will only succeed if osvrClientCheckDisplayStartup() succeeds.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param flags Bitwise OR of matrix convention flags (see @ref MatrixFlags)<br>
	 * @param mat Pass a double[::OSVR_MATRIX_SIZE] to get the transformation<br>
	 * matrix from room space to eye space (not relative to pose of the viewer)<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or no pose was<br>
	 * yet available, in which case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeViewMatrixd(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_MatrixConventions, double*)</code>
	 */
	public static native byte osvrClientGetViewerEyeViewMatrixd(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, short flags, DoubleBuffer mat);
	/**
	 * Get the view matrix (inverse of pose) for the given eye of a<br>
	 * viewer in a display config - matrix of **floats**.<br>
	 * Will only succeed if osvrClientCheckDisplayStartup() succeeds.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param flags Bitwise OR of matrix convention flags (see @ref MatrixFlags)<br>
	 * @param mat Pass a float[::OSVR_MATRIX_SIZE] to get the transformation<br>
	 * matrix from room space to eye space (not relative to pose of the viewer)<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or no pose was<br>
	 * yet available, in which case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeViewMatrixf(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_MatrixConventions, float*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetViewerEyeViewMatrixf(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, short, java.nio.FloatBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerEyeViewMatrixf(Pointer disp, int viewer, byte eye, short flags, FloatByReference mat);
	/**
	 * Get the view matrix (inverse of pose) for the given eye of a<br>
	 * viewer in a display config - matrix of **floats**.<br>
	 * Will only succeed if osvrClientCheckDisplayStartup() succeeds.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param flags Bitwise OR of matrix convention flags (see @ref MatrixFlags)<br>
	 * @param mat Pass a float[::OSVR_MATRIX_SIZE] to get the transformation<br>
	 * matrix from room space to eye space (not relative to pose of the viewer)<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed or no pose was<br>
	 * yet available, in which case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeViewMatrixf(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_MatrixConventions, float*)</code>
	 */
	public static native byte osvrClientGetViewerEyeViewMatrixf(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, short flags, FloatBuffer mat);
	/**
	 * Each eye of each viewer in a display config has one or more surfaces<br>
	 * (aka "screens") on which content should be rendered.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surfaces Number of surfaces (numbered [0, surfaces - 1]) for the<br>
	 * given viewer and eye. **Constant** throughout the active, valid lifetime of<br>
	 * a display config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetNumSurfacesForViewerEye(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetNumSurfacesForViewerEye(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, java.nio.IntBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetNumSurfacesForViewerEye(Pointer disp, int viewer, byte eye, IntByReference surfaces);
	/**
	 * Each eye of each viewer in a display config has one or more surfaces<br>
	 * (aka "screens") on which content should be rendered.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surfaces Number of surfaces (numbered [0, surfaces - 1]) for the<br>
	 * given viewer and eye. **Constant** throughout the active, valid lifetime of<br>
	 * a display config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetNumSurfacesForViewerEye(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount*)</code>
	 */
	public static native byte osvrClientGetNumSurfacesForViewerEye(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, IntBuffer surfaces);
	/**
	 * Get the dimensions/location of the viewport **within the display<br>
	 * input** for a surface seen by an eye of a viewer in a display config. (This<br>
	 * does not include other video inputs that may be on a single virtual desktop,<br>
	 * etc. or explicitly account for display configurations that use multiple<br>
	 * video inputs. It does not necessarily indicate that a viewport in the sense<br>
	 * of glViewport must be created with these parameters, though the parameter<br>
	 * order matches for convenience.)<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param left Output: Distance in pixels from the left of the video input<br>
	 * to the left of the viewport.<br>
	 * @param bottom Output: Distance in pixels from the bottom of the video<br>
	 * input to the bottom of the viewport.<br>
	 * @param width Output: Width of viewport in pixels.<br>
	 * @param height Output: Height of viewport in pixels.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output arguments are unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetRelativeViewportForViewerEyeSurface(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_ViewportDimension*, OSVR_ViewportDimension*, OSVR_ViewportDimension*, OSVR_ViewportDimension*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetRelativeViewportForViewerEyeSurface(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetRelativeViewportForViewerEyeSurface(Pointer disp, int viewer, byte eye, int surface, IntByReference left, IntByReference bottom, IntByReference width, IntByReference height);
	/**
	 * Get the dimensions/location of the viewport **within the display<br>
	 * input** for a surface seen by an eye of a viewer in a display config. (This<br>
	 * does not include other video inputs that may be on a single virtual desktop,<br>
	 * etc. or explicitly account for display configurations that use multiple<br>
	 * video inputs. It does not necessarily indicate that a viewport in the sense<br>
	 * of glViewport must be created with these parameters, though the parameter<br>
	 * order matches for convenience.)<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param left Output: Distance in pixels from the left of the video input<br>
	 * to the left of the viewport.<br>
	 * @param bottom Output: Distance in pixels from the bottom of the video<br>
	 * input to the bottom of the viewport.<br>
	 * @param width Output: Width of viewport in pixels.<br>
	 * @param height Output: Height of viewport in pixels.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output arguments are unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetRelativeViewportForViewerEyeSurface(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_ViewportDimension*, OSVR_ViewportDimension*, OSVR_ViewportDimension*, OSVR_ViewportDimension*)</code>
	 */
	public static native byte osvrClientGetRelativeViewportForViewerEyeSurface(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, int surface, IntBuffer left, IntBuffer bottom, IntBuffer width, IntBuffer height);
	/**
	 * Get the index of the display input for a surface seen by an eye of a<br>
	 * viewer in a display config.<br>
	 * This is the OSVR-assigned display input: it may not (and in practice,<br>
	 * usually will not) match any platform-specific display indices. This function<br>
	 * exists to associate surfaces with video inputs as enumerated by<br>
	 * osvrClientGetNumDisplayInputs().<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param displayInput Zero-based index of the display input pixels for<br>
	 * this surface are tranmitted over.<br>
	 * This association is **constant** throughout the active, valid lifetime of a<br>
	 * display config object.<br>
         * @see #osvrClientGetNumDisplayInputs(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, java.nio.ByteBuffer) 
         * @see #osvrClientGetRelativeViewportForViewerEyeSurface(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which<br>
	 * case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceDisplayInputIndex(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_DisplayInputCount*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetViewerEyeSurfaceDisplayInputIndex(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, java.nio.ByteBuffer)} 
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerEyeSurfaceDisplayInputIndex(Pointer disp, int viewer, byte eye, int surface, Pointer displayInput);
	/**
	 * Get the index of the display input for a surface seen by an eye of a<br>
	 * viewer in a display config.<br>
	 * This is the OSVR-assigned display input: it may not (and in practice,<br>
	 * usually will not) match any platform-specific display indices. This function<br>
	 * exists to associate surfaces with video inputs as enumerated by<br>
	 * osvrClientGetNumDisplayInputs().<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param displayInput Zero-based index of the display input pixels for<br>
	 * this surface are tranmitted over.<br>
	 * This association is **constant** throughout the active, valid lifetime of a<br>
	 * display config object.<br>
         * @see #osvrClientGetNumDisplayInputs(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, java.nio.ByteBuffer) 
         * @see #osvrClientGetRelativeViewportForViewerEyeSurface(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which<br>
	 * case the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceDisplayInputIndex(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_DisplayInputCount*)</code>
	 */
	public static native byte osvrClientGetViewerEyeSurfaceDisplayInputIndex(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, int surface, ByteBuffer displayInput);
	/**
	 * Get the projection matrix for a surface seen by an eye of a viewer<br>
	 * in a display config. (double version)<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param near Distance from viewpoint to near clipping plane - must be<br>
	 * positive.<br>
	 * @param far Distance from viewpoint to far clipping plane - must be positive<br>
	 * and not equal to near, typically greater than near.<br>
	 * @param flags Bitwise OR of matrix convention flags (see @ref MatrixFlags)<br>
	 * @param matrix Output projection matrix: supply an array of 16<br>
	 * (::OSVR_MATRIX_SIZE) doubles.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceProjectionMatrixd(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, double, double, OSVR_MatrixConventions, double*)</code><br>
	 * @deprecated use the safer method 
         * {@link #osvrClientGetViewerEyeSurfaceProjectionMatrixd(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, double, double, short, java.nio.DoubleBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerEyeSurfaceProjectionMatrixd(Pointer disp, int viewer, byte eye, int surface, double near, double far, short flags, DoubleByReference matrix);
	/**
	 * Get the projection matrix for a surface seen by an eye of a viewer<br>
	 * in a display config. (double version)<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param near Distance from viewpoint to near clipping plane - must be<br>
	 * positive.<br>
	 * @param far Distance from viewpoint to far clipping plane - must be positive<br>
	 * and not equal to near, typically greater than near.<br>
	 * @param flags Bitwise OR of matrix convention flags (see @ref MatrixFlags)<br>
	 * @param matrix Output projection matrix: supply an array of 16<br>
	 * (::OSVR_MATRIX_SIZE) doubles.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceProjectionMatrixd(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, double, double, OSVR_MatrixConventions, double*)</code>
	 */
	public static native byte osvrClientGetViewerEyeSurfaceProjectionMatrixd(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, int surface, double near, double far, short flags, DoubleBuffer matrix);
	/**
	 * Get the projection matrix for a surface seen by an eye of a viewer<br>
	 * in a display config. (float version)<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param near Distance to near clipping plane - must be nonzero, typically<br>
	 * positive.<br>
	 * @param far Distance to far clipping plane - must be nonzero, typically<br>
	 * positive and greater than near.<br>
	 * @param flags Bitwise OR of matrix convention flags (see @ref MatrixFlags)<br>
	 * @param matrix Output projection matrix: supply an array of 16<br>
	 * (::OSVR_MATRIX_SIZE) floats.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceProjectionMatrixf(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, float, float, OSVR_MatrixConventions, float*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetViewerEyeSurfaceProjectionMatrixf(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, float, float, short, java.nio.FloatBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerEyeSurfaceProjectionMatrixf(Pointer disp, int viewer, byte eye, int surface, float near, float far, short flags, FloatByReference matrix);
	/**
	 * Get the projection matrix for a surface seen by an eye of a viewer<br>
	 * in a display config. (float version)<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param near Distance to near clipping plane - must be nonzero, typically<br>
	 * positive.<br>
	 * @param far Distance to far clipping plane - must be nonzero, typically<br>
	 * positive and greater than near.<br>
	 * @param flags Bitwise OR of matrix convention flags (see @ref MatrixFlags)<br>
	 * @param matrix Output projection matrix: supply an array of 16<br>
	 * (::OSVR_MATRIX_SIZE) floats.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceProjectionMatrixf(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, float, float, OSVR_MatrixConventions, float*)</code>
	 */
	public static native byte osvrClientGetViewerEyeSurfaceProjectionMatrixf(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, int surface, float near, float far, short flags, FloatBuffer matrix);
	/**
	 * Get the clipping planes (positions at unit distance) for a surface<br>
	 * seen by an eye of a viewer<br>
	 * in a display config.<br>
	 * This is only for use in integrations that cannot accept a fully-formulated<br>
	 * projection matrix as returned by<br>
	 * osvrClientGetViewerEyeSurfaceProjectionMatrixf() or<br>
	 * osvrClientGetViewerEyeSurfaceProjectionMatrixd(), and may not necessarily<br>
	 * provide the same optimizations.<br>
	 * As all the planes are given at unit (1) distance, before passing these<br>
	 * planes to a consuming function in your application/engine, you will typically<br>
	 * divide them by your near clipping plane distance.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param left Distance to left clipping plane<br>
	 * @param right Distance to right clipping plane<br>
	 * @param bottom Distance to bottom clipping plane<br>
	 * @param top Distance to top clipping plane<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output arguments are unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceProjectionClippingPlanes(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, double*, double*, double*, double*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetViewerEyeSurfaceProjectionClippingPlanes(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerEyeSurfaceProjectionClippingPlanes(Pointer disp, int viewer, byte eye, int surface, DoubleByReference left, DoubleByReference right, DoubleByReference bottom, DoubleByReference top);
	/**
	 * Get the clipping planes (positions at unit distance) for a surface<br>
	 * seen by an eye of a viewer<br>
	 * in a display config.<br>
	 * This is only for use in integrations that cannot accept a fully-formulated<br>
	 * projection matrix as returned by<br>
	 * osvrClientGetViewerEyeSurfaceProjectionMatrixf() or<br>
	 * osvrClientGetViewerEyeSurfaceProjectionMatrixd(), and may not necessarily<br>
	 * provide the same optimizations.<br>
	 * As all the planes are given at unit (1) distance, before passing these<br>
	 * planes to a consuming function in your application/engine, you will typically<br>
	 * divide them by your near clipping plane distance.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param left Distance to left clipping plane<br>
	 * @param right Distance to right clipping plane<br>
	 * @param bottom Distance to bottom clipping plane<br>
	 * @param top Distance to top clipping plane<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output arguments are unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceProjectionClippingPlanes(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, double*, double*, double*, double*)</code>
	 */
	public static native byte osvrClientGetViewerEyeSurfaceProjectionClippingPlanes(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, int surface, DoubleBuffer left, DoubleBuffer right, DoubleBuffer bottom, DoubleBuffer top);
	/**
	 * Determines if a surface seen by an eye of a viewer in a display<br>
	 * config requests some distortion to be performed.<br>
	 * This simply reports true or false, and does not specify which kind of<br>
	 * distortion implementations have been parameterized for this display. For<br>
	 * each distortion implementation your application supports, you'll want to<br>
	 * call the corresponding priority function to find out if it is available.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param distortionRequested Output parameter: whether distortion is<br>
	 * requested. **Constant** throughout the active, valid lifetime of a display<br>
	 * config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientDoesViewerEyeSurfaceWantDistortion(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_CBool*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientDoesViewerEyeSurfaceWantDistortion(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, java.nio.ByteBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientDoesViewerEyeSurfaceWantDistortion(Pointer disp, int viewer, byte eye, int surface, Pointer distortionRequested);
	/**
	 * Determines if a surface seen by an eye of a viewer in a display<br>
	 * config requests some distortion to be performed.<br>
	 * This simply reports true or false, and does not specify which kind of<br>
	 * distortion implementations have been parameterized for this display. For<br>
	 * each distortion implementation your application supports, you'll want to<br>
	 * call the corresponding priority function to find out if it is available.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param distortionRequested Output parameter: whether distortion is<br>
	 * requested. **Constant** throughout the active, valid lifetime of a display<br>
	 * config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientDoesViewerEyeSurfaceWantDistortion(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_CBool*)</code>
	 */
	public static native byte osvrClientDoesViewerEyeSurfaceWantDistortion(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, int surface, ByteBuffer distortionRequested);
	/**
	 * Returns the priority/availability of radial distortion parameters for<br>
	 * a surface seen by an eye of a viewer in a display config.<br>
	 * If osvrClientDoesViewerEyeSurfaceWantDistortion() reports false, then the<br>
	 * display does not request distortion of any sort, and thus neither this nor<br>
	 * any other distortion strategy priority function will report an "available"<br>
	 * priority.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param priority Output: the priority level. Negative values<br>
	 * (canonically OSVR_DISTORTION_PRIORITY_UNAVAILABLE) indicate this technique<br>
	 * not available, higher values indicate higher preference for the given<br>
	 * technique based on the device's description. **Constant** throughout the<br>
	 * active, valid lifetime of a display config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceRadialDistortionPriority(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_DistortionPriority*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetViewerEyeSurfaceRadialDistortionPriority(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, java.nio.IntBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerEyeSurfaceRadialDistortionPriority(Pointer disp, int viewer, byte eye, int surface, IntByReference priority);
	/**
	 * Returns the priority/availability of radial distortion parameters for<br>
	 * a surface seen by an eye of a viewer in a display config.<br>
	 * If osvrClientDoesViewerEyeSurfaceWantDistortion() reports false, then the<br>
	 * display does not request distortion of any sort, and thus neither this nor<br>
	 * any other distortion strategy priority function will report an "available"<br>
	 * priority.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param priority Output: the priority level. Negative values<br>
	 * (canonically OSVR_DISTORTION_PRIORITY_UNAVAILABLE) indicate this technique<br>
	 * not available, higher values indicate higher preference for the given<br>
	 * technique based on the device's description. **Constant** throughout the<br>
	 * active, valid lifetime of a display config object.<br>
	 * @return OSVR_RETURN_FAILURE if invalid parameters were passed, in which case<br>
	 * the output argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceRadialDistortionPriority(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_DistortionPriority*)</code>
	 */
	public static native byte osvrClientGetViewerEyeSurfaceRadialDistortionPriority(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, int surface, IntBuffer priority);
	/**
	 * Returns the radial distortion parameters, if known/requested, for a<br>
	 * surface seen by an eye of a viewer in a display config.<br>
	 * Will only succeed if osvrClientGetViewerEyeSurfaceRadialDistortionPriority()<br>
	 * reports a non-negative priority.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param params Output: the parameters for radial distortion<br>
	 * @return OSVR_RETURN_FAILURE if this surface does not have these parameters<br>
	 * described, or if invalid parameters were passed, in which case the output<br>
	 * argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceRadialDistortion(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_RadialDistortionParameters*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrClientGetViewerEyeSurfaceRadialDistortion(com.jme3.system.osvr.osvrdisplay.OsvrDisplayLibrary.OSVR_DisplayConfig, int, byte, int, com.sun.jna.Pointer)} 
         * instead
	 */
	@Deprecated 
	public static native byte osvrClientGetViewerEyeSurfaceRadialDistortion(Pointer disp, int viewer, byte eye, int surface, Pointer params);
	/**
	 * Returns the radial distortion parameters, if known/requested, for a<br>
	 * surface seen by an eye of a viewer in a display config.<br>
	 * Will only succeed if osvrClientGetViewerEyeSurfaceRadialDistortionPriority()<br>
	 * reports a non-negative priority.<br>
	 * @param disp Display config object<br>
	 * @param viewer Viewer ID<br>
	 * @param eye Eye ID<br>
	 * @param surface Surface ID<br>
	 * @param params Output: the parameters for radial distortion<br>
	 * @return OSVR_RETURN_FAILURE if this surface does not have these parameters<br>
	 * described, or if invalid parameters were passed, in which case the output<br>
	 * argument is unmodified.<br>
	 * Original signature : <code>OSVR_ReturnCode osvrClientGetViewerEyeSurfaceRadialDistortion(OSVR_DisplayConfig, OSVR_ViewerCount, OSVR_EyeCount, OSVR_SurfaceCount, OSVR_RadialDistortionParameters*)</code>
	 */
	public static native byte osvrClientGetViewerEyeSurfaceRadialDistortion(OsvrDisplayLibrary.OSVR_DisplayConfig disp, int viewer, byte eye, int surface, Pointer params);
	public static class OSVR_ClientContext extends PointerType {
		public OSVR_ClientContext(Pointer address) {
			super(address);
		}
		public OSVR_ClientContext() {
			super();
		}
	};
	public static class OSVR_DisplayConfig extends PointerType {
		public OSVR_DisplayConfig(Pointer address) {
			super(address);
		}
		public OSVR_DisplayConfig() {
			super();
		}
	};
}
