package com.jme3.system.osvr.osvrmatrixconventions;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.FloatByReference;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
/**
 * JNA Wrapper for library <b>osvrMatrixConventions</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class OsvrMatrixConventionsLibrary implements Library {
	public static final String JNA_LIBRARY_NAME = "osvrUtil";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(OsvrMatrixConventionsLibrary.JNA_LIBRARY_NAME);
	static {
		Native.register(OsvrMatrixConventionsLibrary.class, OsvrMatrixConventionsLibrary.JNA_NATIVE_LIB);
	}
	/** enum values */
	public static interface OSVR_MatrixMasks {
		public static final int OSVR_MATRIX_MASK_ROWMAJOR = 0x1;
		public static final int OSVR_MATRIX_MASK_ROWVECTORS = 0x2;
		public static final int OSVR_MATRIX_MASK_LHINPUT = 0x4;
		public static final int OSVR_MATRIX_MASK_UNSIGNEDZ = 0x8;
	};
	/** enum values */
	public static interface OSVR_MatrixOrderingFlags {
		public static final int OSVR_MATRIX_COLMAJOR = 0x0;
		public static final int OSVR_MATRIX_ROWMAJOR = (int)OsvrMatrixConventionsLibrary.OSVR_MatrixMasks.OSVR_MATRIX_MASK_ROWMAJOR;
	};
	/** enum values */
	public static interface OSVR_MatrixVectorFlags {
		public static final int OSVR_MATRIX_COLVECTORS = 0x0;
		public static final int OSVR_MATRIX_ROWVECTORS = (int)OsvrMatrixConventionsLibrary.OSVR_MatrixMasks.OSVR_MATRIX_MASK_ROWVECTORS;
	};
	/** enum values */
	public static interface OSVR_ProjectionMatrixInputFlags {
		public static final int OSVR_MATRIX_RHINPUT = 0x0;
		public static final int OSVR_MATRIX_LHINPUT = (int)OsvrMatrixConventionsLibrary.OSVR_MatrixMasks.OSVR_MATRIX_MASK_LHINPUT;
	};
	/** enum values */
	public static interface OSVR_ProjectionMatrixZFlags {
		public static final int OSVR_MATRIX_SIGNEDZ = 0x0;
		public static final int OSVR_MATRIX_UNSIGNEDZ = (int)OsvrMatrixConventionsLibrary.OSVR_MatrixMasks.OSVR_MATRIX_MASK_UNSIGNEDZ;
	};
	public static final int OSVR_MATRIX_SIZE = 16;
	public static final int OSVR_RETURN_SUCCESS = (int)(0);
	public static final int OSVR_RETURN_FAILURE = (int)(1);
	/** Original signature : <code>double osvrVec3GetX(const OSVR_Vec3*)</code> */
	public static native double osvrVec3GetX(OSVR_Vec3 v);
	/** Original signature : <code>void osvrVec3SetX(OSVR_Vec3*, double)</code> */
	public static native void osvrVec3SetX(OSVR_Vec3 v, double val);
	/** Original signature : <code>double osvrVec3GetY(const OSVR_Vec3*)</code> */
	public static native double osvrVec3GetY(OSVR_Vec3 v);
	/** Original signature : <code>void osvrVec3SetY(OSVR_Vec3*, double)</code> */
	public static native void osvrVec3SetY(OSVR_Vec3 v, double val);
	/** Original signature : <code>double osvrVec3GetZ(const OSVR_Vec3*)</code> */
	public static native double osvrVec3GetZ(OSVR_Vec3 v);
	/** Original signature : <code>void osvrVec3SetZ(OSVR_Vec3*, double)</code> */
	public static native void osvrVec3SetZ(OSVR_Vec3 v, double val);
	/**
	 * Set a Vec3 to the zero vector<br>
	 * Original signature : <code>void osvrVec3Zero(OSVR_Vec3*)</code>
	 */
	public static native void osvrVec3Zero(OSVR_Vec3 v);
	/** Original signature : <code>double osvrQuatGetW(const OSVR_Quaternion*)</code> */
	public static native double osvrQuatGetW(OSVR_Quaternion q);
	/** Original signature : <code>void osvrQuatSetW(OSVR_Quaternion*, double)</code> */
	public static native void osvrQuatSetW(OSVR_Quaternion q, double val);
	/** Original signature : <code>double osvrQuatGetX(const OSVR_Quaternion*)</code> */
	public static native double osvrQuatGetX(OSVR_Quaternion q);
	/** Original signature : <code>void osvrQuatSetX(OSVR_Quaternion*, double)</code> */
	public static native void osvrQuatSetX(OSVR_Quaternion q, double val);
	/** Original signature : <code>double osvrQuatGetY(const OSVR_Quaternion*)</code> */
	public static native double osvrQuatGetY(OSVR_Quaternion q);
	/** Original signature : <code>void osvrQuatSetY(OSVR_Quaternion*, double)</code> */
	public static native void osvrQuatSetY(OSVR_Quaternion q, double val);
	/** Original signature : <code>double osvrQuatGetZ(const OSVR_Quaternion*)</code> */
	public static native double osvrQuatGetZ(OSVR_Quaternion q);
	/** Original signature : <code>void osvrQuatSetZ(OSVR_Quaternion*, double)</code> */
	public static native void osvrQuatSetZ(OSVR_Quaternion q, double val);
	/**
	 * Set a quaternion to the identity rotation<br>
	 * Original signature : <code>void osvrQuatSetIdentity(OSVR_Quaternion*)</code>
	 */
	public static native void osvrQuatSetIdentity(OSVR_Quaternion q);
	/**
	 * Set a pose to identity<br>
	 * Original signature : <code>void osvrPose3SetIdentity(OSVR_Pose3*)</code>
	 */
	public static native void osvrPose3SetIdentity(OSVR_Pose3 pose);
	/**
	 * Set a matrix of doubles based on a Pose3.<br>
	 * @param pose The Pose3 to convert<br>
	 * @param flags Memory ordering flag - see @ref MatrixFlags<br>
	 * @param mat an array of 16 doubles<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrixd(const OSVR_Pose3*, OSVR_MatrixConventions, double*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrPose3ToMatrixd(com.jme3.system.osvr.osvrmatrixconventions.OSVR_Pose3, short, java.nio.DoubleBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrPose3ToMatrixd(OSVR_Pose3 pose, short flags, DoubleByReference mat);
	/**
	 * Set a matrix of doubles based on a Pose3.<br>
	 * @param pose The Pose3 to convert<br>
	 * @param flags Memory ordering flag - see @ref MatrixFlags<br>
	 * @param mat an array of 16 doubles<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrixd(const OSVR_Pose3*, OSVR_MatrixConventions, double*)</code>
	 */
	public static native byte osvrPose3ToMatrixd(OSVR_Pose3 pose, short flags, DoubleBuffer mat);
	/**
	 * Set a matrix of floats based on a Pose3.<br>
	 * @param pose The Pose3 to convert<br>
	 * @param flags Memory ordering flag - see @ref MatrixFlags<br>
	 * @param mat an array of 16 floats<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrixf(const OSVR_Pose3*, OSVR_MatrixConventions, float*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrPose3ToMatrixf(com.jme3.system.osvr.osvrmatrixconventions.OSVR_Pose3, short, java.nio.FloatBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrPose3ToMatrixf(OSVR_Pose3 pose, short flags, FloatByReference mat);
	/**
	 * Set a matrix of floats based on a Pose3.<br>
	 * @param pose The Pose3 to convert<br>
	 * @param flags Memory ordering flag - see @ref MatrixFlags<br>
	 * @param mat an array of 16 floats<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrixf(const OSVR_Pose3*, OSVR_MatrixConventions, float*)</code>
	 */
	public static native byte osvrPose3ToMatrixf(OSVR_Pose3 pose, short flags, FloatBuffer mat);
	/**
	 * Set a matrix based on a Pose3. (C++-only overload - detecting scalar<br>
	 * type)<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrix(const OSVR_Pose3*, OSVR_MatrixConventions, double*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrPose3ToMatrix(com.jme3.system.osvr.osvrmatrixconventions.OSVR_Pose3, short, java.nio.DoubleBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrPose3ToMatrix(OSVR_Pose3 pose, short flags, DoubleByReference mat);
	/**
	 * Set a matrix based on a Pose3. (C++-only overload - detecting scalar<br>
	 * type)<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrix(const OSVR_Pose3*, OSVR_MatrixConventions, double*)</code>
	 */
	public static native byte osvrPose3ToMatrix(OSVR_Pose3 pose, short flags, DoubleBuffer mat);
	/**
	 * Set a matrix based on a Pose3. (C++-only overload - detecting scalar<br>
	 * type)<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrix(const OSVR_Pose3*, OSVR_MatrixConventions, float*)</code><br>
	 * @deprecated use the safer method
         * {@link #osvrPose3ToMatrix(com.jme3.system.osvr.osvrmatrixconventions.OSVR_Pose3, short, java.nio.FloatBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrPose3ToMatrix(OSVR_Pose3 pose, short flags, FloatByReference mat);
	/**
	 * Set a matrix based on a Pose3. (C++-only overload - detecting scalar<br>
	 * type)<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrix(const OSVR_Pose3*, OSVR_MatrixConventions, float*)</code>
	 */
	public static native byte osvrPose3ToMatrix(OSVR_Pose3 pose, short flags, FloatBuffer mat);
	/**
	 * Set a matrix based on a Pose3. (C++-only overload - detects scalar<br>
	 * and takes array rather than pointer)<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrix(const OSVR_Pose3*, OSVR_MatrixConventions, Scalar[OSVR_MATRIX_SIZE])</code><br>
	 * @deprecated use the safer method
         * {@link #osvrPose3ToMatrix(com.jme3.system.osvr.osvrmatrixconventions.OSVR_Pose3, short, java.nio.DoubleBuffer)}
         * instead
	 */
	@Deprecated 
	public static native byte osvrPose3ToMatrix(OSVR_Pose3 pose, short flags, Pointer mat);
	/**
	 * Set a matrix based on a Pose3. (C++-only overload - detects scalar<br>
	 * and takes array rather than pointer)<br>
	 * Original signature : <code>OSVR_ReturnCode osvrPose3ToMatrix(const OSVR_Pose3*, OSVR_MatrixConventions, Scalar[OSVR_MATRIX_SIZE])</code>
	 */
	public static native byte osvrPose3ToMatrix(OSVR_Pose3 pose, short flags, OsvrMatrixConventionsLibrary.Scalar mat[]);
	public static class Scalar extends PointerType {
		public Scalar(Pointer address) {
			super(address);
		}
		public Scalar() {
			super();
		}
	};
}
