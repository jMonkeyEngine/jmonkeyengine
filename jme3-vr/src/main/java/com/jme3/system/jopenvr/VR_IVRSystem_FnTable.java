package com.jme3.system.jopenvr;
import com.sun.jna.Callback;
import com.sun.jna.Pointer;
import com.sun.jna.Structure;
import com.sun.jna.ptr.FloatByReference;
import com.sun.jna.ptr.IntByReference;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.util.Arrays;
import java.util.List;
/**
 * OpenVR Function Pointer Tables<br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class VR_IVRSystem_FnTable extends Structure {
	/** C type : GetRecommendedRenderTargetSize_callback* */
	public VR_IVRSystem_FnTable.GetRecommendedRenderTargetSize_callback GetRecommendedRenderTargetSize;
	/** C type : GetProjectionMatrix_callback* */
	public VR_IVRSystem_FnTable.GetProjectionMatrix_callback GetProjectionMatrix;
	/** C type : GetProjectionRaw_callback* */
	public VR_IVRSystem_FnTable.GetProjectionRaw_callback GetProjectionRaw;
	/** C type : ComputeDistortion_callback* */
	public VR_IVRSystem_FnTable.ComputeDistortion_callback ComputeDistortion;
	/** C type : GetEyeToHeadTransform_callback* */
	public VR_IVRSystem_FnTable.GetEyeToHeadTransform_callback GetEyeToHeadTransform;
	/** C type : GetTimeSinceLastVsync_callback* */
	public VR_IVRSystem_FnTable.GetTimeSinceLastVsync_callback GetTimeSinceLastVsync;
	/** C type : GetD3D9AdapterIndex_callback* */
	public VR_IVRSystem_FnTable.GetD3D9AdapterIndex_callback GetD3D9AdapterIndex;
	/** C type : GetDXGIOutputInfo_callback* */
	public com.jme3.system.jopenvr.VR_IVRExtendedDisplay_FnTable.GetDXGIOutputInfo_callback GetDXGIOutputInfo;
	/** C type : IsDisplayOnDesktop_callback* */
	public VR_IVRSystem_FnTable.IsDisplayOnDesktop_callback IsDisplayOnDesktop;
	/** C type : SetDisplayVisibility_callback* */
	public VR_IVRSystem_FnTable.SetDisplayVisibility_callback SetDisplayVisibility;
	/** C type : GetDeviceToAbsoluteTrackingPose_callback* */
	public VR_IVRSystem_FnTable.GetDeviceToAbsoluteTrackingPose_callback GetDeviceToAbsoluteTrackingPose;
	/** C type : ResetSeatedZeroPose_callback* */
	public VR_IVRSystem_FnTable.ResetSeatedZeroPose_callback ResetSeatedZeroPose;
	/** C type : GetSeatedZeroPoseToStandingAbsoluteTrackingPose_callback* */
	public VR_IVRSystem_FnTable.GetSeatedZeroPoseToStandingAbsoluteTrackingPose_callback GetSeatedZeroPoseToStandingAbsoluteTrackingPose;
	/** C type : GetRawZeroPoseToStandingAbsoluteTrackingPose_callback* */
	public VR_IVRSystem_FnTable.GetRawZeroPoseToStandingAbsoluteTrackingPose_callback GetRawZeroPoseToStandingAbsoluteTrackingPose;
	/** C type : GetSortedTrackedDeviceIndicesOfClass_callback* */
	public VR_IVRSystem_FnTable.GetSortedTrackedDeviceIndicesOfClass_callback GetSortedTrackedDeviceIndicesOfClass;
	/** C type : GetTrackedDeviceActivityLevel_callback* */
	public VR_IVRSystem_FnTable.GetTrackedDeviceActivityLevel_callback GetTrackedDeviceActivityLevel;
	/** C type : ApplyTransform_callback* */
	public VR_IVRSystem_FnTable.ApplyTransform_callback ApplyTransform;
	/** C type : GetTrackedDeviceIndexForControllerRole_callback* */
	public VR_IVRSystem_FnTable.GetTrackedDeviceIndexForControllerRole_callback GetTrackedDeviceIndexForControllerRole;
	/** C type : GetControllerRoleForTrackedDeviceIndex_callback* */
	public VR_IVRSystem_FnTable.GetControllerRoleForTrackedDeviceIndex_callback GetControllerRoleForTrackedDeviceIndex;
	/** C type : GetTrackedDeviceClass_callback* */
	public VR_IVRSystem_FnTable.GetTrackedDeviceClass_callback GetTrackedDeviceClass;
	/** C type : IsTrackedDeviceConnected_callback* */
	public VR_IVRSystem_FnTable.IsTrackedDeviceConnected_callback IsTrackedDeviceConnected;
	/** C type : GetBoolTrackedDeviceProperty_callback* */
	public VR_IVRSystem_FnTable.GetBoolTrackedDeviceProperty_callback GetBoolTrackedDeviceProperty;
	
	/** 
	 * Returns a static property for a tracked device. 
	 * The different typed GetXTrackedDeviceProperty functions return a value on failure that is generally reasonable for that type:
	 * <ul> 
     * <li>GetBoolTrackedDeviceProperty - false
     * <li>GetFloatTrackedDeviceProperty - 0.0
     * <li>GetInt32TrackedDeviceProperty - 0
     * <li>GetUint64TrackedDeviceProperty - 0
     * <li>GetMatrix34TrackedDeviceProperty - identity matrix
     * <li>GetStringTrackedDeviceProperty - 0 (and 0-length string)
	 * </ul>
	 * <p>
	 * <b>String Properties</b><br>
	 * Because the application owns the buffer to fill with a string property, retrieving a string property is a little different. 
	 * <code>GetStringTrackedDeviceProperty</code> returns the number of bytes necessary to hold the string, including the trailing null. 
	 * If the buffer wasn't large enough it passes back TrackedProp_BufferTooSmall as the error and doesn't fill the string into the buffer.
	 * Strings will generally fit in buffers of k_unTrackingStringSize characters.
	 * <p>
	 * <b>Property Errors</b><br>
	 * TrackedPropertyError will be one of:
	 * <ul>
	 * <li>TrackedProp_Success - The property request was successful.
	 * <li>TrackedProp_WrongDataType - The property was requested with the wrong typed function.
	 * <li>TrackedProp_WrongDeviceClass - The property was requested on a tracked device with the wrong class.
	 * <li>TrackedProp_BufferTooSmall - The string property will not fit in the provided buffer. The buffer size needed is returned.
	 * <li>TrackedProp_UnknownProperty - The property enum value is unknown.
	 * <li>TrackedProp_InvalidDevice - The tracked device index was invalid.
	 * <li>TrackedProp_CouldNotContactServer - OpenVR could not contact vrserver to query the device for this property.
	 * <li>TrackedProp_ValueNotProvidedByDevice - The driver for this device returned that it does not provide this specific property for this device.
	 * <li>TrackedProp_StringExceedsMaximumLength - The string property value returned by a driver exceeded the maximum property length of 32k.
     * </ul>
	 */
	public VR_IVRSystem_FnTable.GetFloatTrackedDeviceProperty_callback GetFloatTrackedDeviceProperty;
	
	/** C type : GetInt32TrackedDeviceProperty_callback* */
	public VR_IVRSystem_FnTable.GetInt32TrackedDeviceProperty_callback GetInt32TrackedDeviceProperty;
	/** C type : GetUint64TrackedDeviceProperty_callback* */
	public VR_IVRSystem_FnTable.GetUint64TrackedDeviceProperty_callback GetUint64TrackedDeviceProperty;
	/** C type : GetMatrix34TrackedDeviceProperty_callback* */
	public VR_IVRSystem_FnTable.GetMatrix34TrackedDeviceProperty_callback GetMatrix34TrackedDeviceProperty;
	/** C type : GetStringTrackedDeviceProperty_callback* */
	public VR_IVRSystem_FnTable.GetStringTrackedDeviceProperty_callback GetStringTrackedDeviceProperty;
	/** C type : GetPropErrorNameFromEnum_callback* */
	public VR_IVRSystem_FnTable.GetPropErrorNameFromEnum_callback GetPropErrorNameFromEnum;
	/** C type : PollNextEvent_callback* */
	public VR_IVRSystem_FnTable.PollNextEvent_callback PollNextEvent;
	/** C type : PollNextEventWithPose_callback* */
	public VR_IVRSystem_FnTable.PollNextEventWithPose_callback PollNextEventWithPose;
	/** C type : GetEventTypeNameFromEnum_callback* */
	public VR_IVRSystem_FnTable.GetEventTypeNameFromEnum_callback GetEventTypeNameFromEnum;
	/** C type : GetHiddenAreaMesh_callback* */
	public VR_IVRSystem_FnTable.GetHiddenAreaMesh_callback GetHiddenAreaMesh;
	/** C type : GetControllerState_callback* */
	public VR_IVRSystem_FnTable.GetControllerState_callback GetControllerState;
	/** C type : GetControllerStateWithPose_callback* */
	public VR_IVRSystem_FnTable.GetControllerStateWithPose_callback GetControllerStateWithPose;
	
	
	/**
	 * Trigger a single haptic pulse on a controller.
	 * <ul>
     * <li><code>vr::TrackedDeviceIndex_t unControllerDeviceIndex</code> - The tracked device index of the controller to trigger a haptic pulse on.
     * <li><code>uint32_t unAxisId</code> - The ID of the axis to trigger a haptic pulse on.
     * <li><code>unsigned short usDurationMicroSec</code> - The duration of the desired haptic pulse in microseconds.
     * </ul>
     * <p>
     * <b>Description</b><br>
     * Trigger a single haptic pulse on a controller.<br>
     * Note: After this call the application may not trigger another haptic pulse on this controller and axis combination for 5ms.
	 * <p>
	 * see <a href="https://github.com/ValveSoftware/openvr/wiki/IVRSystem::TriggerHapticPulse">IVRSystem::TriggerHapticPulse</a>
	 */
	public VR_IVRSystem_FnTable.TriggerHapticPulse_callback TriggerHapticPulse;
	
	
	/** C type : GetButtonIdNameFromEnum_callback* */
	public VR_IVRSystem_FnTable.GetButtonIdNameFromEnum_callback GetButtonIdNameFromEnum;
	/** C type : GetControllerAxisTypeNameFromEnum_callback* */
	public VR_IVRSystem_FnTable.GetControllerAxisTypeNameFromEnum_callback GetControllerAxisTypeNameFromEnum;
	/** C type : CaptureInputFocus_callback* */
	public VR_IVRSystem_FnTable.CaptureInputFocus_callback CaptureInputFocus;
	/** C type : ReleaseInputFocus_callback* */
	public VR_IVRSystem_FnTable.ReleaseInputFocus_callback ReleaseInputFocus;
	/** C type : IsInputFocusCapturedByAnotherProcess_callback* */
	public VR_IVRSystem_FnTable.IsInputFocusCapturedByAnotherProcess_callback IsInputFocusCapturedByAnotherProcess;
	/** C type : DriverDebugRequest_callback* */
	public VR_IVRSystem_FnTable.DriverDebugRequest_callback DriverDebugRequest;
	/** C type : PerformFirmwareUpdate_callback* */
	public VR_IVRSystem_FnTable.PerformFirmwareUpdate_callback PerformFirmwareUpdate;
	/** C type : AcknowledgeQuit_Exiting_callback* */
	public VR_IVRSystem_FnTable.AcknowledgeQuit_Exiting_callback AcknowledgeQuit_Exiting;
	/** C type : AcknowledgeQuit_UserPrompt_callback* */
	public VR_IVRSystem_FnTable.AcknowledgeQuit_UserPrompt_callback AcknowledgeQuit_UserPrompt;
	/** C type : PerformanceTestEnableCapture_callback* */
	public interface GetRecommendedRenderTargetSize_callback extends Callback {
		void apply(IntBuffer pnWidth, IntBuffer pnHeight);
	};
	public interface GetProjectionMatrix_callback extends Callback {
		com.jme3.system.jopenvr.HmdMatrix44_t.ByValue apply(int eEye, float fNearZ, float fFarZ, int eProjType);
	};
	public interface GetProjectionRaw_callback extends Callback {
		void apply(int eEye, FloatByReference pfLeft, FloatByReference pfRight, FloatByReference pfTop, FloatByReference pfBottom);
	};
	public interface ComputeDistortion_callback extends Callback {
		com.jme3.system.jopenvr.DistortionCoordinates_t.ByValue apply(int eEye, float fU, float fV);
	};
	public interface GetEyeToHeadTransform_callback extends Callback {
		HmdMatrix34_t.ByValue apply(int eEye);
	};
	public interface GetTimeSinceLastVsync_callback extends Callback {
		byte apply(FloatBuffer pfSecondsSinceLastVsync, LongBuffer pulFrameCounter);
	};
	public interface GetD3D9AdapterIndex_callback extends Callback {
		int apply();
	};
	public interface GetDXGIOutputInfo_callback extends Callback {
		void apply(IntByReference pnAdapterIndex);
	};
	public interface IsDisplayOnDesktop_callback extends Callback {
		byte apply();
	};
	public interface SetDisplayVisibility_callback extends Callback {
		byte apply(byte bIsVisibleOnDesktop);
	};
	public interface GetDeviceToAbsoluteTrackingPose_callback extends Callback {
		void apply(int eOrigin, float fPredictedSecondsToPhotonsFromNow, TrackedDevicePose_t pTrackedDevicePoseArray, int unTrackedDevicePoseArrayCount);
	};
	public interface ResetSeatedZeroPose_callback extends Callback {
		void apply();
	};
	public interface GetSeatedZeroPoseToStandingAbsoluteTrackingPose_callback extends Callback {
		HmdMatrix34_t.ByValue apply();
	};
	public interface GetRawZeroPoseToStandingAbsoluteTrackingPose_callback extends Callback {
		HmdMatrix34_t.ByValue apply();
	};
	public interface GetSortedTrackedDeviceIndicesOfClass_callback extends Callback {
		int apply(int eTrackedDeviceClass, IntByReference punTrackedDeviceIndexArray, int unTrackedDeviceIndexArrayCount, int unRelativeToTrackedDeviceIndex);
	};
	public interface GetTrackedDeviceActivityLevel_callback extends Callback {
		int apply(int unDeviceId);
	};
	public interface ApplyTransform_callback extends Callback {
		void apply(TrackedDevicePose_t pOutputPose, TrackedDevicePose_t pTrackedDevicePose, HmdMatrix34_t pTransform);
	};
	public interface GetTrackedDeviceIndexForControllerRole_callback extends Callback {
		int apply(int unDeviceType);
	};
	public interface GetControllerRoleForTrackedDeviceIndex_callback extends Callback {
		int apply(int unDeviceIndex);
	};
	public interface GetTrackedDeviceClass_callback extends Callback {
		int apply(int unDeviceIndex);
	};
	public interface IsTrackedDeviceConnected_callback extends Callback {
		byte apply(int unDeviceIndex);
	};
	public interface GetBoolTrackedDeviceProperty_callback extends Callback {
		byte apply(int unDeviceIndex, int prop, IntBuffer pError);
	};
	
	/**
	 * <a href="https://github.com/ValveSoftware/openvr/wiki/IVRSystem::GetTrackedDeviceProperty">IVRSystem::GetTrackedDeviceProperty</a> encapsulation.
	 */
	public interface GetFloatTrackedDeviceProperty_callback extends Callback {

		/** 
		 * Returns a static property for a tracked device. 
		 * The different typed GetXTrackedDeviceProperty functions return a value on failure that is generally reasonable for that type:
		 * <ul> 
	     * <li>GetBoolTrackedDeviceProperty - false
	     * <li>GetFloatTrackedDeviceProperty - 0.0
	     * <li>GetInt32TrackedDeviceProperty - 0
	     * <li>GetUint64TrackedDeviceProperty - 0
	     * <li>GetMatrix34TrackedDeviceProperty - identity matrix
	     * <li>GetStringTrackedDeviceProperty - 0 (and 0-length string)
		 * </ul>
		 * <p>
		 * <b>String Properties</b><br>
		 * Because the application owns the buffer to fill with a string property, retrieving a string property is a little different. 
		 * <code>GetStringTrackedDeviceProperty</code> returns the number of bytes necessary to hold the string, including the trailing null. 
		 * If the buffer wasn't large enough it passes back TrackedProp_BufferTooSmall as the error and doesn't fill the string into the buffer.
		 * Strings will generally fit in buffers of k_unTrackingStringSize characters.
		 * <p>
		 * <b>Property Errors</b><br>
		 * TrackedPropertyError will be one of:
		 * <ul>
		 * <li>TrackedProp_Success - The property request was successful.
		 * <li>TrackedProp_WrongDataType - The property was requested with the wrong typed function.
		 * <li>TrackedProp_WrongDeviceClass - The property was requested on a tracked device with the wrong class.
		 * <li>TrackedProp_BufferTooSmall - The string property will not fit in the provided buffer. The buffer size needed is returned.
		 * <li>TrackedProp_UnknownProperty - The property enum value is unknown.
		 * <li>TrackedProp_InvalidDevice - The tracked device index was invalid.
		 * <li>TrackedProp_CouldNotContactServer - OpenVR could not contact vrserver to query the device for this property.
		 * <li>TrackedProp_ValueNotProvidedByDevice - The driver for this device returned that it does not provide this specific property for this device.
		 * <li>TrackedProp_StringExceedsMaximumLength - The string property value returned by a driver exceeded the maximum property length of 32k.
	     * </ul>
	     * <p>
	     * see <a href="https://github.com/ValveSoftware/openvr/wiki/IVRSystem::GetTrackedDeviceProperty">IVRSystem::GetTrackedDeviceProperty</a>.
	     * @param unDeviceIndex Index of the device to get the property for.
	     * @param prop Which property to get.
		 * @param pError The error returned when attempting to fetch this property. This can be NULL if the caller doesn't care about the source of a property error.
	     * @return the float value of the property.
		 */
		float apply(int unDeviceIndex, int prop, IntBuffer pError);
	};
	public interface GetInt32TrackedDeviceProperty_callback extends Callback {
		int apply(int unDeviceIndex, int prop, IntBuffer pError);
	};
	public interface GetUint64TrackedDeviceProperty_callback extends Callback {
		long apply(int unDeviceIndex, int prop, IntBuffer pError);
	};
	public interface GetMatrix34TrackedDeviceProperty_callback extends Callback {
		HmdMatrix34_t.ByValue apply(int unDeviceIndex, int prop, IntByReference pError);
	};
	public interface GetStringTrackedDeviceProperty_callback extends Callback {
		int apply(int unDeviceIndex, int prop, Pointer pchValue, int unBufferSize, IntBuffer pError);
	};
	public interface GetPropErrorNameFromEnum_callback extends Callback {
		Pointer apply(int error);
	};
	public interface PollNextEvent_callback extends Callback {
		byte apply(VREvent_t pEvent, int uncbVREvent);
	};
	public interface PollNextEventWithPose_callback extends Callback {
		byte apply(int eOrigin, VREvent_t pEvent, int uncbVREvent, TrackedDevicePose_t pTrackedDevicePose);
	};
	public interface GetEventTypeNameFromEnum_callback extends Callback {
		Pointer apply(int eType);
	};
	public interface GetHiddenAreaMesh_callback extends Callback {
		com.jme3.system.jopenvr.HiddenAreaMesh_t.ByValue apply(int eEye);
	};
	public interface GetControllerState_callback extends Callback {
		byte apply(int unControllerDeviceIndex, VRControllerState_t pControllerState);
	};
	public interface GetControllerStateWithPose_callback extends Callback {
		byte apply(int eOrigin, int unControllerDeviceIndex, VRControllerState_t pControllerState, TrackedDevicePose_t pTrackedDevicePose);
	};
	
	
	/**
	 * <a href="https://github.com/ValveSoftware/openvr/wiki/IVRSystem::TriggerHapticPulse">IVRSystem::TriggerHapticPulse</a> encapsulation.
	 */
	public interface TriggerHapticPulse_callback extends Callback {
		
		/**
         * Trigger a single haptic pulse on a controller.<br><br>
         * Note: After this call the application may not trigger another haptic pulse on this controller and axis combination for 5ms.
	     * <p>
	     * see <a href="https://github.com/ValveSoftware/openvr/wiki/IVRSystem::TriggerHapticPulse">IVRSystem::TriggerHapticPulse</a>
		 * @param unControllerDeviceIndex The tracked device index of the controller to trigger a haptic pulse on.
		 * @param unAxisId The ID of the axis to trigger a haptic pulse on.
		 * @param usDurationMicroSec The duration of the desired haptic pulse in microseconds.
		 */
		void apply(int unControllerDeviceIndex, int unAxisId, short usDurationMicroSec);
	};
	public interface GetButtonIdNameFromEnum_callback extends Callback {
		Pointer apply(int eButtonId);
	};
	public interface GetControllerAxisTypeNameFromEnum_callback extends Callback {
		Pointer apply(int eAxisType);
	};
	public interface CaptureInputFocus_callback extends Callback {
		byte apply();
	};
	public interface ReleaseInputFocus_callback extends Callback {
		void apply();
	};
	public interface IsInputFocusCapturedByAnotherProcess_callback extends Callback {
		byte apply();
	};
	public interface DriverDebugRequest_callback extends Callback {
		int apply(int unDeviceIndex, Pointer pchRequest, Pointer pchResponseBuffer, int unResponseBufferSize);
	};
	public interface PerformFirmwareUpdate_callback extends Callback {
		int apply(int unDeviceIndex);
	};
	public interface AcknowledgeQuit_Exiting_callback extends Callback {
		void apply();
	};
	public interface AcknowledgeQuit_UserPrompt_callback extends Callback {
		void apply();
	};
	public VR_IVRSystem_FnTable() {
		super();
	}
	protected List<String> getFieldOrder() {
		return Arrays.asList("GetRecommendedRenderTargetSize", "GetProjectionMatrix", "GetProjectionRaw", "ComputeDistortion", "GetEyeToHeadTransform", "GetTimeSinceLastVsync", "GetD3D9AdapterIndex", "GetDXGIOutputInfo", "IsDisplayOnDesktop", "SetDisplayVisibility", "GetDeviceToAbsoluteTrackingPose", "ResetSeatedZeroPose", "GetSeatedZeroPoseToStandingAbsoluteTrackingPose", "GetRawZeroPoseToStandingAbsoluteTrackingPose", "GetSortedTrackedDeviceIndicesOfClass", "GetTrackedDeviceActivityLevel", "ApplyTransform", "GetTrackedDeviceIndexForControllerRole", "GetControllerRoleForTrackedDeviceIndex", "GetTrackedDeviceClass", "IsTrackedDeviceConnected", "GetBoolTrackedDeviceProperty", "GetFloatTrackedDeviceProperty", "GetInt32TrackedDeviceProperty", "GetUint64TrackedDeviceProperty", "GetMatrix34TrackedDeviceProperty", "GetStringTrackedDeviceProperty", "GetPropErrorNameFromEnum", "PollNextEvent", "PollNextEventWithPose", "GetEventTypeNameFromEnum", "GetHiddenAreaMesh", "GetControllerState", "GetControllerStateWithPose", "TriggerHapticPulse", "GetButtonIdNameFromEnum", "GetControllerAxisTypeNameFromEnum", "CaptureInputFocus", "ReleaseInputFocus", "IsInputFocusCapturedByAnotherProcess", "DriverDebugRequest", "PerformFirmwareUpdate", "AcknowledgeQuit_Exiting", "AcknowledgeQuit_UserPrompt");
	}
	public VR_IVRSystem_FnTable(Pointer peer) {
		super(peer);
	}
	public static class ByReference extends VR_IVRSystem_FnTable implements Structure.ByReference {
		
	};
	public static class ByValue extends VR_IVRSystem_FnTable implements Structure.ByValue {
		
	};
}
