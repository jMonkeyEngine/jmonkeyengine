// OpenAL Soft r1.16
String openALSoftUrl = 'http://repo.or.cz/w/openal-soft.git/snapshot/e5016f814a265ed592a88acea95cf912c4bfdf12.zip'
String openALSoftZipFile = 'OpenALSoft.zip'

// OpenAL Soft directory the download is extracted into
// Typically, the downloaded OpenAL Soft zip file will extract to a directory
// called "openal-soft"
String openALSoftFolder = 'openal-soft-e5016f8'

//Working directories for the ndk build.
String openalsoftBuildDir = "${buildDir}" + File.separator + 'openalsoft'
String openalsoftClassesBuildDir = "${buildDir}" + File.separator + 'openalsoft_classes'
String openalsoftBuildJniDir = openalsoftBuildDir + File.separator + 'jni'
String openalsoftBuildLibsDir = openalsoftBuildDir + File.separator + 'libs'

//Pre-compiled libs directory
String openalsoftPreCompiledLibsDir = 'libs' + File.separator + 'openalsoft'

// jME Android Native source files path
String openalsoftJmeAndroidPath = 'src/native/jme_openalsoft'

// Download external source files if not available
task downloadOpenALSoft(type: MyDownload) {
    sourceUrl = openALSoftUrl
    target = file(openalsoftBuildDir + File.separator + openALSoftZipFile)
}

// Unzip external source files
task unzipOpenALSoft(type: Copy) {
    def zipFile = file(openalsoftBuildDir + File.separator + openALSoftZipFile)
    def outputDir = file(openalsoftBuildDir)

    from zipTree(zipFile)
    into outputDir
}
unzipOpenALSoft.dependsOn {
    def zipFilePath = openalsoftBuildDir + File.separator + openALSoftZipFile
    def zipFile = new File(zipFilePath)
//    println "zipFile path: " + zipFile.absolutePath
//    println "zipFile exists: " + zipFile.exists()
    if (!zipFile.exists()) {
        downloadOpenALSoft
    }
}

// Copy external source files to jni directory
task copyOpenALSoft(type: Copy) {
    def sourceDir = file(openalsoftBuildDir + File.separator + openALSoftFolder)
    def outputDir = file(openalsoftBuildJniDir)
//    println "copyOpenALSoft sourceDir: " + sourceDir
//    println "copyOpenALSoft outputDir: " + outputDir

    from sourceDir
    into outputDir
}
copyOpenALSoft.dependsOn {
    def openALSoftUnzipDir = new File(project.projectDir.absolutePath + File.separator + openALSoftFolder)
//    println "openALSoftUnzipDir path: " + openALSoftUnzipDir.absolutePath
//    println "openALSoftUnzipDir exists: " + openALSoftUnzipDir.isDirectory()
    if (!openALSoftUnzipDir.isDirectory()) {
        unzipOpenALSoft
    }
}

// Copy jME Android native files to jni directory
task copyJmeOpenALSoft(type: Copy, dependsOn:copyOpenALSoft) {
    def sourceDir = file(openalsoftJmeAndroidPath)
    def outputDir = file(openalsoftBuildJniDir)
//    println "copyJmeOpenALSoft sourceDir: " + sourceDir
//    println "copyJmeOpenALSoft outputDir: " + outputDir

    from sourceDir
    into outputDir
}

task generateOpenAlSoftHeaders(type:Exec, dependsOn: copyJmeOpenALSoft) {
    def files0 = fileTree("src/main/java/").filter { it.isFile() && it.getName().endsWith(".java") }.files
    def files1 = fileTree("src/common/java/").filter { it.isFile() && it.getName().endsWith(".java") }.files
    def files2 = fileTree("../jme3-core/src/main/java/").filter { it.isFile() && it.getName().endsWith(".java") }.files
    def files3 = fileTree("../jme3-core/src/plugins/java/").filter { it.isFile() && it.getName().endsWith(".java") }.files
    def files4 = fileTree("../jme3-core/src/tools/java/").filter { it.isFile() && it.getName().endsWith(".java") }.files
    def files5 = fileTree("../jme3-terrain/src/main/java/").filter { it.isFile() && it.getName().endsWith(".java") }.files
    def filesList = "\"" + files0.join("\"\n\"") + "\"\n\"" + files1.join("\"\n\"") + "\"\n\"" + files2.join("\"\n\"") + "\"\n\"" + files3.join("\"\n\"") + "\"\n\"" + files4.join("\"\n\"") + "\"\n\"" + files5.join("\"\n\"") + "\""
	new File("$projectDir/java_classes.jtxt").text = filesList.replaceAll(java.util.regex.Pattern.quote("\\"), java.util.regex.Matcher.quoteReplacement("/"))
    executable org.gradle.internal.jvm.Jvm.current().getExecutable('javac')
    args '-h', openalsoftJmeAndroidPath
    args "@$projectDir/java_classes.jtxt"
    args '-d', openalsoftClassesBuildDir
}

task buildOpenAlSoftNativeLib(type: Exec, dependsOn: generateOpenAlSoftHeaders) {
//    println "openalsoft build dir: " + openalsoftBuildDir
//    println "ndkCommandPath: " + project.ndkCommandPath
    workingDir openalsoftBuildDir
    executable rootProject.ndkCommandPath
    args "-j" + Runtime.runtime.availableProcessors()
}

task updatePreCompiledOpenAlSoftLibs(type: Copy, dependsOn: buildOpenAlSoftNativeLib) {
    def sourceDir = new File(openalsoftBuildLibsDir)
    def outputDir = new File(openalsoftPreCompiledLibsDir)
//    println "updatePreCompiledOpenAlSoftLibs sourceDir: " + sourceDir
//    println "updatePreCompiledOpenAlSoftLibs outputDir: " + outputDir

    from sourceDir
    into outputDir
}


// Copy pre-compiled libs to build directory (when not building new libs)
task copyPreCompiledOpenAlSoftLibs(type: Copy) {
    def sourceDir = file(openalsoftPreCompiledLibsDir)
    def outputDir = file(openalsoftBuildLibsDir)
//    println "copyStbiJmeFiles sourceDir: " + sourceDir
//    println "copyStbiJmeFiles outputDir: " + outputDir

    from sourceDir
    into outputDir
}

// ndkExists is a boolean from the build.gradle in the root project
// buildNativeProjects is a string set to "true"
if (ndkExists && buildNativeProjects == "true") {
    // build native libs and update stored pre-compiled libs to commit
    compileJava.dependsOn { updatePreCompiledOpenAlSoftLibs }
} else {
    // use pre-compiled native libs (not building new ones)
    compileJava.dependsOn { copyPreCompiledOpenAlSoftLibs }
}

jar.into("lib") { from openalsoftBuildLibsDir }

// Helper class to wrap ant dowload task
class MyDownload extends DefaultTask {
    @Input
    String sourceUrl

    @OutputFile
    File target

    @TaskAction
    void download() {
       ant.get(src: sourceUrl, dest: target)
    }
}
