
Stuck, again. I need a good way to access vertex data. The current system has some flaws:

    1. Processes must assume the format and number of components of an attribute.
       This is especially concerning.
    2. Data cannot be accessed as struct buffers. This not a huge issue.
    3. Attributes are accessed by a string identifier.

I want to have a more concrete way to work with attributes. Something along these lines:

public interface PositionAttribute {
    void setPosition(int vertex, Vector3f position);
    Vector3f getPosition(int vertex);
    void setPositionAccess(DataAccess access);
}

The problem is that a single attribute can get fairly bloated if you also add nice things like bulk setters and getters. Multiply that by every attribute you want, and it can get quite unwieldy. It also has that odd access setter on each attribute, which for whatever reason really annoys me.

What would actually be ideal is if everything could be represented by a simple "Vertex" struct.

struct Vertex {
    Vector3f position;
    Vector2f texCoord;
    Vector3f normal;
}

(of course, in Java struct declaration is more complicated). The advantage is that all the vertex buffers can be very simply mapped as buffers of Vertex. It would also translate fairly well to instances.

struct Instance {
    Matrix4f worldViewProjection;
    Vector4f color;
}

The problem is what to do with vertex data split across multiple buffers, which could very well be done if multiple shaders want to access the vertex positions, but not everything wants the texCoord and normal data. In which case it'd be represented as so:

struct VertexPart1 {
    Vector3f position;
}
struct VertexPart2 {
    Vector2f texCoord;
    Vector3f normal;
}

User-side, this wouldn't be much of a problem. He should know what type of vertex he's working with. But the engine utilities don't necessarily know that. The vertex struct would have to implement an interface (possibly for each attribute, as discussed above), and the utility would have to cast each individual vertex to the desired type.

for (Vertex v : mesh.getVertices()) {
    ((Position)v).setPosition(Vector3f.ZERO);
}

It's messy and a pain to work with. It also doesn't properly address the dual vertex buffer situation. A possible solution to this is custom iterators which will automatically verify that an entire batch of vertices already meets the requirements. It would work something like this:

for (Position p : mesh.getVertices(Position.class)) {
    p.setPosition(Vector3f.ZERO);
}
for (TexCoord t : mesh.getVertices(TexCoord.class)) {
    t.setTexCoord(Vector2f.ZERO);
}
mesh.unmap(); // unmap all used buffers

getVertices() implementation may look something like this:

public class Mesh {
    private final Collection<VertexBuffer<?>> buffers = new ArrayList<>();
    private final Map<Class<? extends VertexAttribute>, VertexBuffer<?>> bufferLookup = new HashMap<>();
    public <T extends VertexAttribute> Iterable<T> getVertices(Class<T> type) {
        VertexBuffer<?> buf = bufferLookup.get(type);
        if (buf != null) {
            return buf.getVertices(type);
        }
        for (VertexBuffer<?> buffer : buffers) {
            if (type.isAssignableFrom(buffer.getVertexType())) {
                bufferLookup.put(type, buffer);
                return buffer.getVertices(type);
            }
        }
        throw new IllegalArgumentException("Mesh does not contain " + type);
    }
}
public class VertexBuffer <V extends Vertex> {
    private final Class<V> vertexType;
    private final GpuBuffer buffer;
    public <T extends VertexAttribute> Iterable<T> getVertices(Class<T> type) {
        if (!type.isAssignableFrom(vertexType)) {
            throw new ClassCastException("Vertex data is not " + type);
        }
        return (Iterable<T>)map();
    }
    public Iterable<V> map() {
        return buffer.map((Long address, Integer size) -> V.Buffer.create(address, size));
    }
    public Class<V> getVertexType() {
        return vertexType;
    }
}

Unfortunately, this doesn't make accessing two different attributes at once very do-able. You'd have to do an awkward multi-iterator loop, which is just a pain to do. It would be better to have to do this:

List<Position> pos = mesh.getVertices(Position.class);
List<TexCoord> tex = mesh.getVertices(TexCoord.class);
pos.get(12).setPosition(tex.get(11).toVector3f());

How about this:

Position pos = mesh.getAttribute(Position.class);
TexCoord tex = mesh.getAttribute(TexCoord.class);
pos.set(12, 0f, 0f, 0f);
Vector3f v = pos.get(11);
for (Vector3f v : pos) {

}
for (int i : Attributes.iterate(pos, tex)) {

}

public interface Attribute <T> extends Iterable<T> {

    Attribute<T> map();

    void set(int element, T value);

    T get(int element);

    int size();

    // optional
    default T get(int element, T store) {
        return get(element);
    }

    @Override
    default Iterator<T> iterator() {
        return new IteratorImpl<>(null);
    }

    default IteratorImpl<T> iterator(T store) {
        return new IteratorImpl<>(store);
    }

    class IteratorImpl <T> implements Iterator<T>, Iterable<T> {

        private final Attribute<T> attr;
        private final T store;
        private int index = 0;

        public IteratorImpl(Attribute<T> attr, T store) {
            this.attr = attr;
            this.store = store;
        }

        public boolean hasNext() {
            return index < attr.size();
        }

        public T next() {
            return attr.get(index++, store);
        }

        public Iterator<T> iterator() {
            this.index = 0;
            return this;
        }

    }

}
public abstract class AbstractAttribute <T> implements Attribute<T> {

    protected final VertexBuffer vertexBuffer;
    protected final int stride, offset, size;
    protected ByteBuffer buffer;

    public AbstractAttribute(VertexBuffer vertexBuffer, int stride, int offset, int size) {
        this.vertexBuffer = vertexBuffer;
    }

}
public class Position implements Attribute<Vector3f> {

    private VertexBuffer buffer;
    private int stride, offset;

    @Override
    public void set(int element, Vector3f value) {
        set(element, value.x, value.y, value.z);
    }

    @Override
    public Vector3f get(int element) {
        Vector3f store = new Vector3f();
        ByteBuffer buf = buffer.map().position(element * stride + offset);
        store.x = buf.getFloat();
        store.y = buf.getFloat();
        store.z = buf.getFloat();
        return store;
    }

    public void set(int element, float x, float y, float z) {
        buffer.map()
            .position(element * stride + offset)
            .putFloat(x).putFloat(y).putFloat(z);
    }

}

If mappings are frequent -> streaming buffer
If mappings are less frequent -> dynamic buffer
If only one mapping occurs OR a mapping hasn't occured in a very long time -> static buffer

Static AND dynamic
    Build
        1. Create GPU buffer (device local)
        2. Create CPU buffer (nio)
    CPU -> GPU
        1. Acquire staging buffer (host visible and coherent)
        2. Map staging buffer
        3. Copy CPU buffer -> staging buffer
        4. Record copy staging buffer -> GPU buffer
        5. Unmap staging buffer
       --- wait for copy to complete
        6. Release staging buffer
    GPU -> CPU
        1. Acquire staging buffer (host visible and coherent)
        2. Copy GPU buffer -> staging buffer
       --- wait for copy to complete
        3. Map staging buffer
        4. Copy staging buffer -> CPU buffer
          OR read directly from staging buffer
          (depends on the nature of the read op)
        5. Unmap staging buffer
        6. Release staging buffer
Streaming
    Build
        1. Create GPU buffers per frame (host visible and coherent)
        2. Create CPU buffer (nio)
    CPU -> GPU
        1. Map frame GPU buffer (if not already mapped)
        2. Copy CPU buffer -> frame GPU buffer
        3. Unmap frame GPU buffer (if necessary)
    GPU -> CPU
        1. Map a GPU buffer (if not already mapped)
        2. Copy GPU buffer -> CPU buffer
        3. Unmap GPU buffer (if necessary)

