<h1><a
name="jmonkeyplatformdebugging_profiling_testing">jMonkeyPlatform: Debugging, Profiling, Testing</a></h1><div
class="level1"><p> Debugging, testing and profiling are important parts of the development cycle. This documentation shows you how to make the most of the jMonkeyPlatform&#039;s assistive features.</p><p> <br/></p><p> Note: Since the jMonkeyPlatform is based on the NetBeans Platform framework, you can learn about certain jMonkeyPlatform features by reading the corresponding NetBeans IDE tutorials (in the &quot;see also links&quot;).</p></div><h2><a
name="testing">Testing</a></h2><div
class="level2"><p> The jMonkeyPlatform supports the JUnit testing framework. It is a good practice to write tests (assertions) for each of your classes. Each test makes certain this &quot;unit&quot; (e.g. method) meets its design and behaves as intended. Run your tests after each major change and you immediately see if you broke something.</p></div><h4><a
name="creating_tests">Creating Tests</a></h4><div
class="level4"><ol><li
class="level1"><div
class="li"> Right-click in a java file in the Projects window and choose Tools &gt; Create JUnit Tests.</div></li><li
class="level1"><div
class="li"> Click OK. The jMonkeyPlatform creates a JUnit test skeleton in the Test Package directory.</div></li><li
class="level1"><div
class="li"> The body of each generated test method is provided solely as a guide. In their place, you need to write your actual test cases!</div></li><li
class="level1"><div
class="li"> You can use tests such as <code>assertTrue(), assertFalse(), assertEquals()</code>, or <code>assert()</code>.</div><ul><li
class="level2"><div
class="li"> Here is an example for assertions that test an addition method: <code>assert( add(1, 1) == 2); assert( add(2,-5) == -3); …</code></div></li></ul></li><li
class="level1"><div
class="li"> &quot;Optimally&quot;, you should write a test case for every method (100% coverage).</div></li></ol><p> <br/> Tip: Use the Navigate menu to jump from a test to its tested class, and back.</p></div><h4><a
name="running_tests">Running Tests</a></h4><div
class="level4"><ol><li
class="level1"><div
class="li"> Right-click the class in the Projects window and Choose Test File, or right-click the project and select Test to run all tests.</div></li><li
class="level1"><div
class="li"> Check the Test window to see successful test (green) and test failures (red).</div></li><li
class="level1"><div
class="li"> If a test fails that has succeeded before, you know that your latest changes broke something!</div></li></ol><p> Using unit tests regularly allows you to detect side-effects on classes that you thought were unaffected by a code change.</p><p> <br/> See also:</p><ul><li
class="level1"><div
class="li"> <a
href="http://netbeans.org/kb/docs/java/junit-intro.html">Writing JUnit Tests</a></div></li><li
class="level1"><div
class="li"> <a
href="http://www.junit.org">http://www.junit.org</a></div></li></ul></div><h2><a
name="debugging">Debugging</a></h2><div
class="level2"><p> In the jMonkeyPlatform, you have access to a debugger to examine your application for errors such as deadlocks and NullPointerExeptions. You can set breakpoints, watch variables, and execute your code line-by-line to identify the source of a problem.</p><ol><li
class="level1"><div
class="li"> First, you set breakpoints and/or watches before the problematic lines of code where you suspect the bug.</div><ul><li
class="level2"><div
class="li"> If you want to watch a variable&#039;s value: Right-click on a variable and select New Watch from the context menu.</div></li><li
class="level2"><div
class="li"> If you want to step through the execution line by line: Right-click on a line and choose Toggle Line Breakpoint; a pink box appears as a mark.</div></li></ul></li><li
class="level1"><div
class="li"> Choose &quot;Debug &gt; Debug Main Project&quot; to start a debugger session for the whole project. Or, right-click in a file and select Debug File to debug only one file.</div></li><li
class="level1"><div
class="li"> The application starts running normally. If you have set a breakpoint, the execution stops. Debugger windows open and print debugger output.</div></li><li
class="level1"><div
class="li"> You can do many things now to track down a bug:</div><ul><li
class="level2"><div
class="li"> Inspect the values of local variables.</div></li><li
class="level2"><div
class="li"> Use the Step buttons in the top to step into, out of, and over expressions while you watch the execution.</div></li><li
class="level2"><div
class="li"> Navigate through your application&#039;s call stack. Right-click on threads to suspend or resume them.</div></li><li
class="level2"><div
class="li"> Choose Debug &gt; Evaluate Expression from the menu to evaluate an expression.</div></li><li
class="level2"><div
class="li"> Move the mouse pointer over a variable to inspect its value in a tooltip.</div></li><li
class="level2"><div
class="li"> Inspect the classes loaded on the heap and the percentage and number of object instances. Right-click a class in the Loaded Classes window and choose Show in Instances view (JDK6 only).</div></li><li
class="level2"><div
class="li"> And more…</div></li></ul></li><li
class="level1"><div
class="li"> To stop debugging, choose Debug &gt; End Debugger Session from the menu.</div></li></ol></div><h2><a
name="profiling">Profiling</a></h2><div
class="level2"><p> The profiler tool is used to monitor thread states, CPU performance, and memory usage of your jme3 application. It helps you detect memory leaks and bottlenecks in your game while it&#039;s running. <br/></p></div><h4><a
name="installing_the_profiler">Installing the Profiler</a></h4><div
class="level4"><p> If you do not see a Profiler menu in the jMonkeyPlatform, you need to download the Profiler plugin first.</p><ol><li
class="level1"><div
class="li"> Open the Tools &gt; Plugins menu, and got to the &quot;Available plugins&quot; tab</div></li><li
class="level1"><div
class="li"> Find the &quot;Java Profiler&quot; plugin (&quot;Java SE&quot; category) and check the Install box.</div></li><li
class="level1"><div
class="li"> Click the install button and follow the instructions.</div></li><li
class="level1"><div
class="li"> When you start the profiler for the first time, you are prompted to run a calibration once. Click OK in the &quot;Profiler integration&quot; dialog to complete the installation process.</div></li></ol></div><h4><a
name="monitoring_and_analyzing">Monitoring and Analyzing</a></h4><div
class="level4"><ol><li
class="level1"><div
class="li"> Choose Profile Project from the Profile menu.</div></li><li
class="level1"><div
class="li"> Select one of three tasks:</div><ul><li
class="level2"><div
class="li"> <strong>Monitor Application</strong> – Collect high-level information about properties of the target JVM, including thread activity and memory allocations.</div></li><li
class="level2"><div
class="li"> <strong>Analyze CPU Performance</strong> – Collect detailed data on application performance, including the time to execute methods and the number of times the method is invoked.</div></li><li
class="level2"><div
class="li"> <strong>Analyze Memory Usage</strong> – Collect detailed data on object allocation and garbage collection.</div></li></ul></li><li
class="level1"><div
class="li"> Click Run. Your application starts and runs normally.</div></li><li
class="level1"><div
class="li"> Use the Profiling window to track and collect live profiling results while you application is running.</div></li></ol></div><h4><a
name="comparing_snapshots">Comparing Snapshots</a></h4><div
class="level4"><p> Click the Take Snapshot button to capture the profiling data for later!</p><ul><li
class="level1"><div
class="li"> You can store and view snapshots in the Profiling window.</div></li><li
class="level1"><div
class="li"> Choose Compare Snapshots from the profiler window to compare two selected snapshots</div></li></ul></div><h4><a
name="using_profiling_points">Using Profiling Points</a></h4><div
class="level4"><p> Profiling points are similar to debugger breakpoints: You place them directly in the source code and they can trigger profiling behaviour when hit.</p><ul><li
class="level1"><div
class="li"> Open a class in the browser, right-click in a line, and select Profiling &gt; Insert Profiling Point to add a profiling point here.</div></li><li
class="level1"><div
class="li"> Use Profiling points if you need a trigger to reset profiling results, take a snapshot or heap dump, record the timestamp or execution time of a code fragment, stop and start a load generator script (requires the load generator plugin).</div></li><li
class="level1"><div
class="li"> Open the Profiling Points window to view, modify and delete the Profiling Points in your projects.</div></li></ul><p> <br/> See also:</p><ul><li
class="level1"><div
class="li"> <a
href="http://netbeans.org/kb/docs/java/profiler-profilingpoints.html">Using Profiling Points</a></div></li><li
class="level1"><div
class="li"> <a
href="http://netbeans.org/kb/docs/java/profiler-intro.html">Introduction to Profiling Java Applications</a></div></li></ul></div>
<p><em><a href="http://jmonkeyengine.org/wiki/doku.php/sdk:debugging_profiling_testing?do=export_xhtmlbody">view online version</a></em></p>